from bees import profiler as p
import itertools
from oslo_config import cfg
from oslo_config import types
from nova.conf import paths
libvirt_group = cfg.OptGroup('libvirt', title='Libvirt Options', help='\nLibvirt options allows cloud administrator to configure related\nlibvirt hypervisor driver to be used within an OpenStack deployment.\n\nAlmost all of the libvirt config options are influence by ``virt_type`` config\nwhich describes the virtualization type (or so called domain type) libvirt\nshould use for specific features such as live migration, snapshot.\n')
libvirt_general_opts = [cfg.StrOpt('rescue_image_id', help="\nThe ID of the image to boot from to rescue data from a corrupted instance.\n\nIf the rescue REST API operation doesn't provide an ID of an image to\nuse, the image which is referenced by this ID is used. If this\noption is not set, the image from the instance is used.\n\nPossible values:\n\n* An ID of an image or nothing. If it points to an *Amazon Machine\n  Image* (AMI), consider to set the config options ``rescue_kernel_id``\n  and ``rescue_ramdisk_id`` too. If nothing is set, the image of the instance\n  is used.\n\nRelated options:\n\n* ``rescue_kernel_id``: If the chosen rescue image allows the separate\n  definition of its kernel disk, the value of this option is used,\n  if specified. This is the case when *Amazon*'s AMI/AKI/ARI image\n  format is used for the rescue image.\n* ``rescue_ramdisk_id``: If the chosen rescue image allows the separate\n  definition of its RAM disk, the value of this option is used if,\n  specified. This is the case when *Amazon*'s AMI/AKI/ARI image\n  format is used for the rescue image.\n"), cfg.StrOpt('rescue_kernel_id', help="\nThe ID of the kernel (AKI) image to use with the rescue image.\n\nIf the chosen rescue image allows the separate definition of its kernel\ndisk, the value of this option is used, if specified. This is the case\nwhen *Amazon*'s AMI/AKI/ARI image format is used for the rescue image.\n\nPossible values:\n\n* An ID of an kernel image or nothing. If nothing is specified, the kernel\n  disk from the instance is used if it was launched with one.\n\nRelated options:\n\n* ``rescue_image_id``: If that option points to an image in *Amazon*'s\n  AMI/AKI/ARI image format, it's useful to use ``rescue_kernel_id`` too.\n"), cfg.StrOpt('rescue_ramdisk_id', help="\nThe ID of the RAM disk (ARI) image to use with the rescue image.\n\nIf the chosen rescue image allows the separate definition of its RAM\ndisk, the value of this option is used, if specified. This is the case\nwhen *Amazon*'s AMI/AKI/ARI image format is used for the rescue image.\n\nPossible values:\n\n* An ID of a RAM disk image or nothing. If nothing is specified, the RAM\n  disk from the instance is used if it was launched with one.\n\nRelated options:\n\n* ``rescue_image_id``: If that option points to an image in *Amazon*'s\n  AMI/AKI/ARI image format, it's useful to use ``rescue_ramdisk_id`` too.\n"), cfg.StrOpt('virt_type', default='kvm', choices=('kvm', 'lxc', 'qemu', 'parallels'), help='\nDescribes the virtualization type (or so called domain type) libvirt should\nuse.\n\nThe choice of this type must match the underlying virtualization strategy\nyou have chosen for this host.\n\nRelated options:\n\n* ``connection_uri``: depends on this\n* ``disk_prefix``: depends on this\n* ``cpu_mode``: depends on this\n* ``cpu_models``: depends on this\n'), cfg.StrOpt('connection_uri', default='', help='\nOverrides the default libvirt URI of the chosen virtualization type.\n\nIf set, Nova will use this URI to connect to libvirt.\n\nPossible values:\n\n* An URI like ``qemu:///system``.\n\n  This is only necessary if the URI differs to the commonly known URIs\n  for the chosen virtualization type.\n\nRelated options:\n\n* ``virt_type``: Influences what is used as default value here.\n'), cfg.BoolOpt('inject_password', default=False, help="\nAllow the injection of an admin password for instance only at ``create`` and\n``rebuild`` process.\n\nThere is no agent needed within the image to do this. If *libguestfs* is\navailable on the host, it will be used. Otherwise *nbd* is used. The file\nsystem of the image will be mounted and the admin password, which is provided\nin the REST API call will be injected as password for the root user. If no\nroot user is available, the instance won't be launched and an error is thrown.\nBe aware that the injection is *not* possible when the instance gets launched\nfrom a volume.\n\n*Linux* distribution guest only.\n\nPossible values:\n\n* True: Allows the injection.\n* False: Disallows the injection. Any via the REST API provided admin password\n  will be silently ignored.\n\nRelated options:\n\n* ``inject_partition``: That option will decide about the discovery and usage\n  of the file system. It also can disable the injection at all.\n"), cfg.BoolOpt('inject_key', default=False, help='\nAllow the injection of an SSH key at boot time.\n\nThere is no agent needed within the image to do this. If *libguestfs* is\navailable on the host, it will be used. Otherwise *nbd* is used. The file\nsystem of the image will be mounted and the SSH key, which is provided\nin the REST API call will be injected as SSH key for the root user and\nappended to the ``authorized_keys`` of that user. The SELinux context will\nbe set if necessary. Be aware that the injection is *not* possible when the\ninstance gets launched from a volume.\n\nThis config option will enable directly modifying the instance disk and does\nnot affect what cloud-init may do using data from config_drive option or the\nmetadata service.\n\n*Linux* distribution guest only.\n\nRelated options:\n\n* ``inject_partition``: That option will decide about the discovery and usage\n  of the file system. It also can disable the injection at all.\n'), cfg.IntOpt('inject_partition', default=-2, min=-2, help="\nDetermines how the file system is chosen to inject data into it.\n\n*libguestfs* is used to inject data. If libguestfs is not able to determine\nthe root partition (because there are more or less than one root partition) or\ncannot mount the file system it will result in an error and the instance won't\nboot.\n\nPossible values:\n\n* -2 => disable the injection of data.\n* -1 => find the root partition with the file system to mount with libguestfs\n*  0 => The image is not partitioned\n* >0 => The number of the partition to use for the injection\n\n*Linux* distribution guest only.\n\nRelated options:\n\n* ``inject_key``: If this option allows the injection of a SSH key it depends\n  on value greater or equal to -1 for ``inject_partition``.\n* ``inject_password``: If this option allows the injection of an admin password\n  it depends on value greater or equal to -1 for ``inject_partition``.\n* ``[guestfs]/debug`` You can enable the debug log level of libguestfs with\n  this config option. A more verbose output will help in debugging issues.\n* ``virt_type``: If you use ``lxc`` as virt_type it will be treated as a\n  single partition image\n"), cfg.StrOpt('live_migration_scheme', help='\nURI scheme for live migration used by the source of live migration traffic.\n\nOverride the default libvirt live migration scheme (which is dependent on\nvirt_type). If this option is set to None, nova will automatically choose a\nsensible default based on the hypervisor. It is not recommended that you change\nthis unless you are very sure that hypervisor supports a particular scheme.\n\nRelated options:\n\n* ``virt_type``: This option is meaningful only when ``virt_type`` is set to\n  `kvm` or `qemu`.\n* ``live_migration_uri``: If ``live_migration_uri`` value is not None, the\n  scheme used for live migration is taken from ``live_migration_uri`` instead.\n'), cfg.HostAddressOpt('live_migration_inbound_addr', help='\nIP address used as the live migration address for this host.\n\nThis option indicates the IP address which should be used as the target for\nlive migration traffic when migrating to this hypervisor. This metadata is then\nused by the source of the live migration traffic to construct a migration URI.\n\nIf this option is set to None, the hostname of the migration target compute\nnode will be used.\n\nThis option is useful in environments where the live-migration traffic can\nimpact the network plane significantly. A separate network for live-migration\ntraffic can then use this config option and avoids the impact on the\nmanagement network.\n'), cfg.StrOpt('live_migration_uri', deprecated_for_removal=True, deprecated_since='15.0.0', deprecated_reason='\nlive_migration_uri is deprecated for removal in favor of two other options that\nallow to change live migration scheme and target URI: ``live_migration_scheme``\nand ``live_migration_inbound_addr`` respectively.\n', help='\nLive migration target URI used by the source of live migration traffic.\n\nOverride the default libvirt live migration target URI (which is dependent\non virt_type). Any included "%s" is replaced with the migration target\nhostname, or `live_migration_inbound_addr` if set.\n\nIf this option is set to None (which is the default), Nova will automatically\ngenerate the `live_migration_uri` value based on only 4 supported `virt_type`\nin following list:\n\n* \'kvm\': \'qemu+tcp://%s/system\'\n* \'qemu\': \'qemu+tcp://%s/system\'\n* \'parallels\': \'parallels+tcp://%s/system\'\n\nRelated options:\n\n* ``live_migration_inbound_addr``: If ``live_migration_inbound_addr`` value\n  is not None and ``live_migration_tunnelled`` is False, the ip/hostname\n  address of target compute node is used instead of ``live_migration_uri`` as\n  the uri for live migration.\n* ``live_migration_scheme``: If ``live_migration_uri`` is not set, the scheme\n  used for live migration is taken from ``live_migration_scheme`` instead.\n'), cfg.BoolOpt('live_migration_tunnelled', default=False, deprecated_for_removal=True, deprecated_since='23.0.0', deprecated_reason='\nThe "tunnelled live migration" has two inherent limitations: it cannot\nhandle live migration of disks in a non-shared storage setup; and it has\na huge performance cost.  Both these problems are solved by\n``live_migration_with_native_tls`` (requires a pre-configured TLS\nenvironment), which is the recommended approach for securing all live\nmigration streams.', help='\nEnable tunnelled migration.\n\nThis option enables the tunnelled migration feature, where migration data is\ntransported over the libvirtd connection. If enabled, we use the\nVIR_MIGRATE_TUNNELLED migration flag, avoiding the need to configure\nthe network to allow direct hypervisor to hypervisor communication.\nIf False, use the native transport. If not set, Nova will choose a\nsensible default based on, for example the availability of native\nencryption support in the hypervisor. Enabling this option will definitely\nimpact performance massively.\n\nNote that this option is NOT compatible with use of block migration.\n'), cfg.IntOpt('live_migration_bandwidth', default=0, help='\nMaximum bandwidth(in MiB/s) to be used during migration.\n\nIf set to 0, the hypervisor will choose a suitable default. Some hypervisors\ndo not support this feature and will return an error if bandwidth is not 0.\nPlease refer to the libvirt documentation for further details.\n'), cfg.IntOpt('live_migration_downtime', default=500, min=100, help='\nMaximum permitted downtime, in milliseconds, for live migration\nswitchover.\n\nWill be rounded up to a minimum of 100ms. You can increase this value\nif you want to allow live-migrations to complete faster, or avoid\nlive-migration timeout errors by allowing the guest to be paused for\nlonger during the live-migration switch over.\n\nRelated options:\n\n* live_migration_completion_timeout\n'), cfg.IntOpt('live_migration_downtime_steps', default=10, min=3, help='\nNumber of incremental steps to reach max downtime value.\n\nWill be rounded up to a minimum of 3 steps.\n'), cfg.IntOpt('live_migration_downtime_delay', default=75, min=3, help='\nTime to wait, in seconds, between each step increase of the migration\ndowntime.\n\nMinimum delay is 3 seconds. Value is per GiB of guest RAM + disk to be\ntransferred, with lower bound of a minimum of 2 GiB per device.\n'), cfg.IntOpt('live_migration_completion_timeout', default=800, min=0, mutable=True, help='\nTime to wait, in seconds, for migration to successfully complete transferring\ndata before aborting the operation.\n\nValue is per GiB of guest RAM + disk to be transferred, with lower bound of\na minimum of 2 GiB. Should usually be larger than downtime delay * downtime\nsteps. Set to 0 to disable timeouts.\n\nRelated options:\n\n* live_migration_downtime\n* live_migration_downtime_steps\n* live_migration_downtime_delay\n'), cfg.StrOpt('live_migration_timeout_action', default='abort', choices=('abort', 'force_complete'), mutable=True, help='\nThis option will be used to determine what action will be taken against a\nVM after ``live_migration_completion_timeout`` expires. By default, the live\nmigrate operation will be aborted after completion timeout. If it is set to\n``force_complete``, the compute service will either pause the VM or trigger\npost-copy depending on if post copy is enabled and available\n(``live_migration_permit_post_copy`` is set to True).\n\nRelated options:\n\n* live_migration_completion_timeout\n* live_migration_permit_post_copy\n'), cfg.BoolOpt('live_migration_permit_post_copy', default=False, help="\nThis option allows nova to switch an on-going live migration to post-copy\nmode, i.e., switch the active VM to the one on the destination node before the\nmigration is complete, therefore ensuring an upper bound on the memory that\nneeds to be transferred. Post-copy requires libvirt>=1.3.3 and QEMU>=2.5.0.\n\nWhen permitted, post-copy mode will be automatically activated if\nwe reach the timeout defined by ``live_migration_completion_timeout`` and\n``live_migration_timeout_action`` is set to 'force_complete'. Note if you\nchange to no timeout or choose to use 'abort',\ni.e. ``live_migration_completion_timeout = 0``, then there will be no\nautomatic switch to post-copy.\n\nThe live-migration force complete API also uses post-copy when permitted. If\npost-copy mode is not available, force complete falls back to pausing the VM\nto ensure the live-migration operation will complete.\n\nWhen using post-copy mode, if the source and destination hosts lose network\nconnectivity, the VM being live-migrated will need to be rebooted. For more\ndetails, please see the Administration guide.\n\nRelated options:\n\n* live_migration_permit_auto_converge\n* live_migration_timeout_action\n"), cfg.BoolOpt('live_migration_permit_auto_converge', default=False, help='\nThis option allows nova to start live migration with auto converge on.\n\nAuto converge throttles down CPU if a progress of on-going live migration\nis slow. Auto converge will only be used if this flag is set to True and\npost copy is not permitted or post copy is unavailable due to the version\nof libvirt and QEMU in use.\n\nRelated options:\n\n    * live_migration_permit_post_copy\n'), cfg.StrOpt('snapshot_image_format', choices=[('raw', 'RAW disk format'), ('qcow2', 'KVM default disk format'), ('vmdk', 'VMWare default disk format'), ('vdi', 'VirtualBox default disk format')], help='\nDetermine the snapshot image format when sending to the image service.\n\nIf set, this decides what format is used when sending the snapshot to the\nimage service. If not set, defaults to same type as source image.\n'), cfg.BoolOpt('live_migration_with_native_tls', default=False, help='\nUse QEMU-native TLS encryption when live migrating.\n\nThis option will allow both migration stream (guest RAM plus device\nstate) *and* disk stream to be transported over native TLS, i.e. TLS\nsupport built into QEMU.\n\nPrerequisite: TLS environment is configured correctly on all relevant\nCompute nodes.  This means, Certificate Authority (CA), server, client\ncertificates, their corresponding keys, and their file permisssions are\nin place, and are validated.\n\nNotes:\n\n* To have encryption for migration stream and disk stream (also called:\n  "block migration"), ``live_migration_with_native_tls`` is the\n  preferred config attribute instead of ``live_migration_tunnelled``.\n\n* The ``live_migration_tunnelled`` will be deprecated in the long-term\n  for two main reasons: (a) it incurs a huge performance penalty; and\n  (b) it is not compatible with block migration.  Therefore, if your\n  compute nodes have at least libvirt 4.4.0 and QEMU 2.11.0, it is\n  strongly recommended to use ``live_migration_with_native_tls``.\n\n* The ``live_migration_tunnelled`` and\n  ``live_migration_with_native_tls`` should not be used at the same\n  time.\n\n* Unlike ``live_migration_tunnelled``, the\n  ``live_migration_with_native_tls`` *is* compatible with block\n  migration.  That is, with this option, NBD stream, over which disks\n  are migrated to a target host, will be encrypted.\n\nRelated options:\n\n``live_migration_tunnelled``: This transports migration stream (but not\ndisk stream) over libvirtd.\n\n'), cfg.StrOpt('disk_prefix', help="\nOverride the default disk prefix for the devices attached to an instance.\n\nIf set, this is used to identify a free disk device name for a bus.\n\nPossible values:\n\n* Any prefix which will result in a valid disk device name like 'sda' or 'hda'\n  for example. This is only necessary if the device names differ to the\n  commonly known device name prefixes for a virtualization type such as: sd,\n  xvd, uvd, vd.\n\nRelated options:\n\n* ``virt_type``: Influences which device type is used, which determines\n  the default disk prefix.\n"), cfg.IntOpt('wait_soft_reboot_seconds', default=120, help='Number of seconds to wait for instance to shut down after soft reboot request is made. We fall back to hard reboot if instance does not shutdown within this window.'), cfg.StrOpt('cpu_mode', choices=[('host-model', 'Clone the host CPU feature flags'), ('host-passthrough', 'Use the host CPU model exactly'), ('custom', 'Use the CPU model in ``[libvirt]cpu_models``'), ('none', "Don't set a specific CPU model. For instances with ``[libvirt] virt_type`` as KVM/QEMU, the default CPU model from QEMU will be used, which provides a basic set of CPU features that are compatible with most hosts")], help='\nIs used to set the CPU mode an instance should have.\n\nIf ``virt_type="kvm|qemu"``, it will default to ``host-model``, otherwise it\nwill default to ``none``.\n\nRelated options:\n\n* ``cpu_models``: This should be set ONLY when ``cpu_mode`` is set to\n  ``custom``. Otherwise, it would result in an error and the instance launch\n  will fail.\n'), cfg.ListOpt('cpu_models', deprecated_name='cpu_model', default=[], help="\nAn ordered list of CPU models the host supports.\n\nIt is expected that the list is ordered so that the more common and less\nadvanced CPU models are listed earlier. Here is an example:\n``SandyBridge,IvyBridge,Haswell,Broadwell``, the latter CPU model's features is\nricher that the previous CPU model.\n\nPossible values:\n\n* The named CPU models can be found via ``virsh cpu-models ARCH``, where\n  ARCH is your host architecture.\n\nRelated options:\n\n* ``cpu_mode``: This should be set to ``custom`` ONLY when you want to\n  configure (via ``cpu_models``) a specific named CPU model.  Otherwise, it\n  would result in an error and the instance launch will fail.\n* ``virt_type``: Only the virtualization types ``kvm`` and ``qemu`` use this.\n\n.. note::\n    Be careful to only specify models which can be fully supported in\n    hardware.\n"), cfg.ListOpt('cpu_model_extra_flags', item_type=types.String(ignore_case=True), default=[], help='\nEnable or disable guest CPU flags.\n\nTo explicitly enable or disable CPU flags, use the ``+flag`` or\n``-flag`` notation -- the ``+`` sign will enable the CPU flag for the\nguest, while a ``-`` sign will disable it.  If neither ``+`` nor ``-``\nis specified, the flag will be enabled, which is the default behaviour.\nFor example, if you specify the following (assuming the said CPU model\nand features are supported by the host hardware and software)::\n\n    [libvirt]\n    cpu_mode = custom\n    cpu_models = Cascadelake-Server\n    cpu_model_extra_flags = -hle, -rtm, +ssbd, mtrr\n\nNova will disable the ``hle`` and ``rtm`` flags for the guest; and it\nwill enable ``ssbd`` and ``mttr`` (because it was specified with neither\n``+`` nor ``-`` prefix).\n\nThe CPU flags are case-insensitive.  In the following example, the\n``pdpe1gb`` flag will be disabled for the guest; ``vmx`` and ``pcid``\nflags will be enabled::\n\n    [libvirt]\n    cpu_mode = custom\n    cpu_models = Haswell-noTSX-IBRS\n    cpu_model_extra_flags = -PDPE1GB, +VMX, pcid\n\nSpecifying extra CPU flags is valid in combination with all the three\npossible values of ``cpu_mode`` config attribute: ``custom`` (this also\nrequires an explicit CPU model to be specified via the ``cpu_models``\nconfig attribute), ``host-model``, or ``host-passthrough``.\n\nThere can be scenarios where you may need to configure extra CPU flags\neven for ``host-passthrough`` CPU mode, because sometimes QEMU may\ndisable certain CPU features.  An example of this is Intel\'s "invtsc"\n(Invariable Time Stamp Counter) CPU flag -- if you need to expose this\nflag to a Nova instance, you need to explicitly enable it.\n\nThe possible values for ``cpu_model_extra_flags`` depends on the CPU\nmodel in use.  Refer to `/usr/share/libvirt/cpu_map/*.xml`` for possible\nCPU feature flags for a given CPU model.\n\nA special note on a particular CPU flag: ``pcid`` (an Intel processor\nfeature that alleviates guest performance degradation as a result of\napplying the \'Meltdown\' CVE fixes).  When configuring this flag with the\n``custom`` CPU mode, not all CPU models (as defined by QEMU and libvirt)\nneed it:\n\n* The only virtual CPU models that include the ``pcid`` capability are\n  Intel "Haswell", "Broadwell", and "Skylake" variants.\n\n* The libvirt / QEMU CPU models "Nehalem", "Westmere", "SandyBridge",\n  and "IvyBridge" will _not_ expose the ``pcid`` capability by default,\n  even if the host CPUs by the same name include it.  I.e. \'PCID\' needs\n  to be explicitly specified when using the said virtual CPU models.\n\nThe libvirt driver\'s default CPU mode, ``host-model``, will do the right\nthing with respect to handling \'PCID\' CPU flag for the guest --\n*assuming* you are running updated processor microcode, host and guest\nkernel, libvirt, and QEMU.  The other mode, ``host-passthrough``, checks\nif \'PCID\' is available in the hardware, and if so directly passes it\nthrough to the Nova guests.  Thus, in context of \'PCID\', with either of\nthese CPU modes (``host-model`` or ``host-passthrough``), there is no\nneed to use the ``cpu_model_extra_flags``.\n\nRelated options:\n\n* cpu_mode\n* cpu_models\n'), cfg.StrOpt('snapshots_directory', default='$instances_path/snapshots', help='Location where libvirt driver will store snapshots before uploading them to image service'), cfg.ListOpt('disk_cachemodes', default=[], help='\nSpecific cache modes to use for different disk types.\n\nFor example: file=directsync,block=none,network=writeback\n\nFor local or direct-attached storage, it is recommended that you use\nwritethrough (default) mode, as it ensures data integrity and has acceptable\nI/O performance for applications running in the guest, especially for read\noperations. However, caching mode none is recommended for remote NFS storage,\nbecause direct I/O operations (O_DIRECT) perform better than synchronous I/O\noperations (with O_SYNC). Caching mode none effectively turns all guest I/O\noperations into direct I/O operations on the host, which is the NFS client in\nthis environment.\n\nPossible cache modes:\n\n* default: "It Depends" -- For Nova-managed disks, ``none``, if the host\n  file system is capable of Linux\'s \'O_DIRECT\' semantics; otherwise\n  ``writeback``.  For volume drivers, the default is driver-dependent:\n  ``none`` for everything except for SMBFS and Virtuzzo (which use\n  ``writeback``).\n* none: With caching mode set to none, the host page cache is disabled, but\n  the disk write cache is enabled for the guest. In this mode, the write\n  performance in the guest is optimal because write operations bypass the host\n  page cache and go directly to the disk write cache. If the disk write cache\n  is battery-backed, or if the applications or storage stack in the guest\n  transfer data properly (either through fsync operations or file system\n  barriers), then data integrity can be ensured. However, because the host\n  page cache is disabled, the read performance in the guest would not be as\n  good as in the modes where the host page cache is enabled, such as\n  writethrough mode. Shareable disk devices, like for a multi-attachable block\n  storage volume, will have their cache mode set to \'none\' regardless of\n  configuration.\n* writethrough: With caching set to writethrough mode, the host page cache is\n  enabled, but the disk write cache is disabled for the guest. Consequently,\n  this caching mode ensures data integrity even if the applications and storage\n  stack in the guest do not transfer data to permanent storage properly (either\n  through fsync operations or file system barriers). Because the host page\n  cache is enabled in this mode, the read performance for applications running\n  in the guest is generally better. However, the write performance might be\n  reduced because the disk write cache is disabled.\n* writeback: With caching set to writeback mode, both the host page\n  cache and the disk write cache are enabled for the guest. Because of\n  this, the I/O performance for applications running in the guest is\n  good, but the data is not protected in a power failure. As a result,\n  this caching mode is recommended only for temporary data where\n  potential data loss is not a concern.\n  NOTE: Certain backend disk mechanisms may provide safe\n  writeback cache semantics. Specifically those that bypass the host\n  page cache, such as QEMU\'s integrated RBD driver. Ceph documentation\n  recommends setting this to writeback for maximum performance while\n  maintaining data safety.\n* directsync: Like "writethrough", but it bypasses the host page cache.\n* unsafe: Caching mode of unsafe ignores cache transfer operations\n  completely. As its name implies, this caching mode should be used only for\n  temporary data where data loss is not a concern. This mode can be useful for\n  speeding up guest installations, but you should switch to another caching\n  mode in production environments.\n'), cfg.StrOpt('rng_dev_path', default='/dev/urandom', help='\nThe path to an RNG (Random Number Generator) device that will be used as\nthe source of entropy on the host.  Since libvirt 1.3.4, any path (that\nreturns random numbers when read) is accepted.  The recommended source\nof entropy is ``/dev/urandom`` -- it is non-blocking, therefore\nrelatively fast; and avoids the limitations of ``/dev/random``, which is\na legacy interface.  For more details (and comparision between different\nRNG sources), refer to the "Usage" section in the Linux kernel API\ndocumentation for ``[u]random``:\nhttp://man7.org/linux/man-pages/man4/urandom.4.html and\nhttp://man7.org/linux/man-pages/man7/random.7.html.\n'), cfg.ListOpt('hw_machine_type', help='For qemu or KVM guests, set this option to specify a default machine type per host architecture. You can find a list of supported machine types in your environment by checking the output of the :command:`virsh capabilities` command. The format of the value for this config option is ``host-arch=machine-type``. For example: ``x86_64=machinetype1,armv7l=machinetype2``.'), cfg.StrOpt('sysinfo_serial', default='unique', choices=(('none', 'A serial number entry is not added to the guest domain xml.'), ('os', 'A UUID serial number is generated from the host ``/etc/machine-id`` file.'), ('hardware', 'A UUID for the host hardware as reported by libvirt. This is typically from the host SMBIOS data, unless it has been overridden in ``libvirtd.conf``.'), ('auto', 'Uses the "os" source if possible, else "hardware".'), ('unique', 'Uses instance UUID as the serial number.')), help='\nThe data source used to the populate the host "serial" UUID exposed to guest\nin the virtual BIOS. All choices except ``unique`` will change the serial when\nmigrating the instance to another host. Changing the choice of this option will\nalso affect existing instances on this host once they are stopped and started\nagain. It is recommended to use the default choice (``unique``) since that will\nnot change when an instance is migrated. However, if you have a need for\nper-host serials in addition to per-instance serial numbers, then consider\nrestricting flavors via host aggregates.\n'), cfg.IntOpt('mem_stats_period_seconds', default=10, help='A number of seconds to memory usage statistics period. Zero or negative value mean to disable memory usage statistics.'), cfg.ListOpt('uid_maps', default=[], help='List of uid targets and ranges.Syntax is guest-uid:host-uid:count. Maximum of 5 allowed.'), cfg.ListOpt('gid_maps', default=[], help='List of guid targets and ranges.Syntax is guest-gid:host-gid:count. Maximum of 5 allowed.'), cfg.IntOpt('realtime_scheduler_priority', default=1, help='In a realtime host context vCPUs for guest will run in that scheduling priority. Priority depends on the host kernel (usually 1-99)'), cfg.ListOpt('enabled_perf_events', default=[], help="\nPerformance events to monitor and collect statistics for.\n\nThis will allow you to specify a list of events to monitor low-level\nperformance of guests, and collect related statistics via the libvirt\ndriver, which in turn uses the Linux kernel's ``perf`` infrastructure.\nWith this config attribute set, Nova will generate libvirt guest XML to\nmonitor the specified events.\n\nFor example, to monitor the count of CPU cycles (total/elapsed) and the\ncount of cache misses, enable them as follows::\n\n    [libvirt]\n    enabled_perf_events = cpu_clock, cache_misses\n\nPossible values: A string list.  The list of supported events can be\nfound `here`__. Note that Intel CMT events - ``cmt``, ``mbmbt`` and\n``mbml`` - are unsupported by recent Linux kernel versions (4.14+) and will be\nignored by nova.\n\n__ https://libvirt.org/formatdomain.html#elementsPerf.\n"), cfg.IntOpt('num_pcie_ports', default=0, min=0, max=28, help="\nThe number of PCIe ports an instance will get.\n\nLibvirt allows a custom number of PCIe ports (pcie-root-port controllers) a\ntarget instance will get. Some will be used by default, rest will be available\nfor hotplug use.\n\nBy default we have just 1-2 free ports which limits hotplug.\n\nMore info: https://github.com/qemu/qemu/blob/master/docs/pcie.txt\n\nDue to QEMU limitations for aarch64/virt maximum value is set to '28'.\n\nDefault value '0' moves calculating amount of ports to libvirt.\n"), cfg.IntOpt('file_backed_memory', default=0, min=0, help="\nAvailable capacity in MiB for file-backed memory.\n\nSet to 0 to disable file-backed memory.\n\nWhen enabled, instances will create memory files in the directory specified\nin ``/etc/libvirt/qemu.conf``'s ``memory_backing_dir`` option. The default\nlocation is ``/var/lib/libvirt/qemu/ram``.\n\nWhen enabled, the value defined for this option is reported as the node memory\ncapacity. Compute node system memory will be used as a cache for file-backed\nmemory, via the kernel's pagecache mechanism.\n\n.. note::\n   This feature is not compatible with hugepages.\n\n.. note::\n   This feature is not compatible with memory overcommit.\n\nRelated options:\n\n* ``virt_type`` must be set to ``kvm`` or ``qemu``.\n* ``ram_allocation_ratio`` must be set to 1.0.\n"), cfg.IntOpt('num_memory_encrypted_guests', default=None, min=0, help="\nMaximum number of guests with encrypted memory which can run\nconcurrently on this compute host.\n\nFor now this is only relevant for AMD machines which support SEV\n(Secure Encrypted Virtualization).  Such machines have a limited\nnumber of slots in their memory controller for storing encryption\nkeys.  Each running guest with encrypted memory will consume one of\nthese slots.\n\nThe option may be reused for other equivalent technologies in the\nfuture.  If the machine does not support memory encryption, the option\nwill be ignored and inventory will be set to 0.\n\nIf the machine does support memory encryption, *for now* a value of\n``None`` means an effectively unlimited inventory, i.e. no limit will\nbe imposed by Nova on the number of SEV guests which can be launched,\neven though the underlying hardware will enforce its own limit.\nHowever it is expected that in the future, auto-detection of the\ninventory from the hardware will become possible, at which point\n``None`` will cause auto-detection to automatically impose the correct\nlimit.\n\n.. note::\n\n   It is recommended to read :ref:`the deployment documentation's\n   section on this option <num_memory_encrypted_guests>` before\n   deciding whether to configure this setting or leave it at the\n   default.\n\nRelated options:\n\n* :oslo.config:option:`libvirt.virt_type` must be set to ``kvm``.\n\n* It's recommended to consider including ``x86_64=q35`` in\n  :oslo.config:option:`libvirt.hw_machine_type`; see\n  :ref:`deploying-sev-capable-infrastructure` for more on this.\n"), cfg.IntOpt('device_detach_attempts', default=8, min=1, help='\nMaximum number of attempts the driver tries to detach a device in libvirt.\n\nRelated options:\n\n* :oslo.config:option:`libvirt.device_detach_timeout`\n\n'), cfg.IntOpt('device_detach_timeout', default=20, min=1, help='\nMaximum number of seconds the driver waits for the success or the failure\nevent from libvirt for a given device detach attempt before it re-trigger the\ndetach.\n\nRelated options:\n\n* :oslo.config:option:`libvirt.device_detach_attempts`\n\n')]
libvirt_imagebackend_opts = [cfg.StrOpt('images_type', default='default', choices=('raw', 'flat', 'qcow2', 'lvm', 'rbd', 'ploop', 'default'), help='\nVM Images format.\n\nIf default is specified, then use_cow_images flag is used instead of this\none.\n\nRelated options:\n\n* compute.use_cow_images\n* images_volume_group\n* [workarounds]/ensure_libvirt_rbd_instance_dir_cleanup\n* compute.force_raw_images\n'), cfg.StrOpt('images_volume_group', help='\nLVM Volume Group that is used for VM images, when you specify images_type=lvm\n\nRelated options:\n\n* images_type\n'), cfg.BoolOpt('sparse_logical_volumes', default=False, deprecated_for_removal=True, deprecated_since='18.0.0', deprecated_reason='\nSparse logical volumes is a feature that is not tested hence not supported.\nLVM logical volumes are preallocated by default. If you want thin provisioning,\nuse Cinder thin-provisioned volumes.\n', help='\nCreate sparse logical volumes (with virtualsize) if this flag is set to True.\n'), cfg.StrOpt('images_rbd_pool', default='rbd', help='The RADOS pool in which rbd volumes are stored'), cfg.StrOpt('images_rbd_ceph_conf', default='', help='Path to the ceph configuration file to use'), cfg.StrOpt('images_rbd_glance_store_name', default='', help='\nThe name of the Glance store that represents the rbd cluster in use by\nthis node. If set, this will allow Nova to request that Glance copy an\nimage from an existing non-local store into the one named by this option\nbefore booting so that proper Copy-on-Write behavior is maintained.\n\nRelated options:\n\n* images_type - must be set to ``rbd``\n* images_rbd_glance_copy_poll_interval - controls the status poll frequency\n* images_rbd_glance_copy_timeout - controls the overall copy timeout\n'), cfg.IntOpt('images_rbd_glance_copy_poll_interval', default=15, help='\nThe interval in seconds with which to poll Glance after asking for it\nto copy an image to the local rbd store. This affects how often we ask\nGlance to report on copy completion, and thus should be short enough that\nwe notice quickly, but not too aggressive that we generate undue load on\nthe Glance server.\n\nRelated options:\n\n* images_type - must be set to ``rbd``\n* images_rbd_glance_store_name - must be set to a store name\n'), cfg.IntOpt('images_rbd_glance_copy_timeout', default=600, help='\nThe overall maximum time we will wait for Glance to complete an image\ncopy to our local rbd store. This should be long enough to allow large\nimages to be copied over the network link between our local store and the\none where images typically reside. The downside of setting this too long\nis just to catch the case where the image copy is stalled or proceeding too\nslowly to be useful. Actual errors will be reported by Glance and noticed\naccording to the poll interval.\n\nRelated options:\n* images_type - must be set to ``rbd``\n* images_rbd_glance_store_name - must be set to a store name\n* images_rbd_glance_copy_poll_interval - controls the failure time-to-notice\n'), cfg.StrOpt('hw_disk_discard', choices=('ignore', 'unmap'), help='\nDiscard option for nova managed disks.\n\nRequires:\n\n* Libvirt >= 1.0.6\n* Qemu >= 1.5 (raw format)\n* Qemu >= 1.6 (qcow2 format)\n')]
libvirt_lvm_opts = [cfg.StrOpt('volume_clear', default='zero', choices=[('zero', 'Overwrite volumes with zeroes'), ('shred', 'Overwrite volumes repeatedly'), ('none', 'Do not wipe deleted volumes')], help='\nMethod used to wipe ephemeral disks when they are deleted. Only takes effect\nif LVM is set as backing storage.\n\nRelated options:\n\n* images_type - must be set to ``lvm``\n* volume_clear_size\n'), cfg.IntOpt('volume_clear_size', default=0, min=0, help='\nSize of area in MiB, counting from the beginning of the allocated volume,\nthat will be cleared using method set in ``volume_clear`` option.\n\nPossible values:\n\n* 0 - clear whole volume\n* >0 - clear specified amount of MiB\n\nRelated options:\n\n* images_type - must be set to ``lvm``\n* volume_clear - must be set and the value must be different than ``none``\n  for this option to have any impact\n')]
libvirt_utils_opts = [cfg.BoolOpt('snapshot_compression', default=False, help='\nEnable snapshot compression for ``qcow2`` images.\n\nNote: you can set ``snapshot_image_format`` to ``qcow2`` to force all\nsnapshots to be in ``qcow2`` format, independently from their original image\ntype.\n\nRelated options:\n\n* snapshot_image_format\n')]
libvirt_vif_opts = [cfg.BoolOpt('use_virtio_for_bridges', default=True, help='Use virtio for bridge interfaces with KVM/QEMU')]
libvirt_volume_opts = [cfg.BoolOpt('volume_use_multipath', default=False, deprecated_name='iscsi_use_multipath', help='\nUse multipath connection of the iSCSI or FC volume\n\nVolumes can be connected in the LibVirt as multipath devices. This will\nprovide high availability and fault tolerance.\n'), cfg.IntOpt('num_volume_scan_tries', deprecated_name='num_iscsi_scan_tries', default=5, help='\nNumber of times to scan given storage protocol to find volume.\n')]
libvirt_volume_aoe_opts = [cfg.IntOpt('num_aoe_discover_tries', default=3, help='\nNumber of times to rediscover AoE target to find volume.\n\nNova provides support for block storage attaching to hosts via AOE (ATA over\nEthernet). This option allows the user to specify the maximum number of retry\nattempts that can be made to discover the AoE device.\n')]
libvirt_volume_iscsi_opts = [cfg.StrOpt('iscsi_iface', deprecated_name='iscsi_transport', help='\nThe iSCSI transport iface to use to connect to target in case offload support\nis desired.\n\nDefault format is of the form ``<transport_name>.<hwaddress>``, where\n``<transport_name>`` is one of (``be2iscsi``, ``bnx2i``, ``cxgb3i``,\n``cxgb4i``, ``qla4xxx``, ``ocs``, ``tcp``) and ``<hwaddress>`` is the MAC\naddress of the interface and can be generated via the ``iscsiadm -m iface``\ncommand. Do not confuse the ``iscsi_iface`` parameter to be provided here with\nthe actual transport name.\n')]
libvirt_volume_iser_opts = [cfg.IntOpt('num_iser_scan_tries', default=5, help='\nNumber of times to scan iSER target to find volume.\n\niSER is a server network protocol that extends iSCSI protocol to use Remote\nDirect Memory Access (RDMA). This option allows the user to specify the maximum\nnumber of scan attempts that can be made to find iSER volume.\n'), cfg.BoolOpt('iser_use_multipath', default=False, help='\nUse multipath connection of the iSER volume.\n\niSER volumes can be connected as multipath devices. This will provide high\navailability and fault tolerance.\n')]
libvirt_volume_net_opts = [cfg.StrOpt('rbd_user', help='\nThe RADOS client name for accessing rbd(RADOS Block Devices) volumes.\n\nLibvirt will refer to this user when connecting and authenticating with\nthe Ceph RBD server.\n'), cfg.StrOpt('rbd_secret_uuid', help='\nThe libvirt UUID of the secret for the rbd_user volumes.\n'), cfg.IntOpt('rbd_connect_timeout', default=5, help='\nThe RADOS client timeout in seconds when initially connecting to the cluster.\n'), cfg.IntOpt('rbd_destroy_volume_retry_interval', default=5, min=0, help="\nNumber of seconds to wait between each consecutive retry to destroy a\nRBD volume.\n\nRelated options:\n\n* [libvirt]/images_type = 'rbd'\n"), cfg.IntOpt('rbd_destroy_volume_retries', default=12, min=0, help="\nNumber of retries to destroy a RBD volume.\n\nRelated options:\n\n* [libvirt]/images_type = 'rbd'\n")]
libvirt_volume_nfs_opts = [cfg.StrOpt('nfs_mount_point_base', default=paths.state_path_def('mnt'), help="\nDirectory where the NFS volume is mounted on the compute node.\nThe default is 'mnt' directory of the location where nova's Python module\nis installed.\n\nNFS provides shared storage for the OpenStack Block Storage service.\n\nPossible values:\n\n* A string representing absolute path of mount point.\n"), cfg.StrOpt('nfs_mount_options', help='\nMount options passed to the NFS client. See section of the nfs man page\nfor details.\n\nMount options controls the way the filesystem is mounted and how the\nNFS client behaves when accessing files on this mount point.\n\nPossible values:\n\n* Any string representing mount options separated by commas.\n* Example string: vers=3,lookupcache=pos\n')]
libvirt_volume_quobyte_opts = [cfg.StrOpt('quobyte_mount_point_base', default=paths.state_path_def('mnt'), help='\nDirectory where the Quobyte volume is mounted on the compute node.\n\nNova supports Quobyte volume driver that enables storing Block Storage\nservice volumes on a Quobyte storage back end. This Option specifies the\npath of the directory where Quobyte volume is mounted.\n\nPossible values:\n\n* A string representing absolute path of mount point.\n'), cfg.StrOpt('quobyte_client_cfg', help='Path to a Quobyte Client configuration file.')]
libvirt_volume_smbfs_opts = [cfg.StrOpt('smbfs_mount_point_base', default=paths.state_path_def('mnt'), help='\nDirectory where the SMBFS shares are mounted on the compute node.\n'), cfg.StrOpt('smbfs_mount_options', default='', help='\nMount options passed to the SMBFS client.\n\nProvide SMBFS options as a single string containing all parameters.\nSee mount.cifs man page for details. Note that the libvirt-qemu ``uid``\nand ``gid`` must be specified.\n')]
libvirt_remotefs_opts = [cfg.StrOpt('remote_filesystem_transport', default='ssh', choices=('ssh', 'rsync'), help="\nlibvirt's transport method for remote file operations.\n\nBecause libvirt cannot use RPC to copy files over network to/from other\ncompute nodes, other method must be used for:\n\n* creating directory on remote host\n* creating file on remote host\n* removing file from remote host\n* copying file to remote host\n")]
libvirt_volume_vzstorage_opts = [cfg.StrOpt('vzstorage_mount_point_base', default=paths.state_path_def('mnt'), help='\nDirectory where the Virtuozzo Storage clusters are mounted on the compute\nnode.\n\nThis option defines non-standard mountpoint for Vzstorage cluster.\n\nRelated options:\n\n* vzstorage_mount_* group of parameters\n'), cfg.StrOpt('vzstorage_mount_user', default='stack', help='\nMount owner user name.\n\nThis option defines the owner user of Vzstorage cluster mountpoint.\n\nRelated options:\n\n* vzstorage_mount_* group of parameters\n'), cfg.StrOpt('vzstorage_mount_group', default='qemu', help='\nMount owner group name.\n\nThis option defines the owner group of Vzstorage cluster mountpoint.\n\nRelated options:\n\n* vzstorage_mount_* group of parameters\n'), cfg.StrOpt('vzstorage_mount_perms', default='0770', help="\nMount access mode.\n\nThis option defines the access bits of Vzstorage cluster mountpoint,\nin the format similar to one of chmod(1) utility, like this: 0770.\nIt consists of one to four digits ranging from 0 to 7, with missing\nlead digits assumed to be 0's.\n\nRelated options:\n\n* vzstorage_mount_* group of parameters\n"), cfg.StrOpt('vzstorage_log_path', default='/var/log/vstorage/%(cluster_name)s/nova.log.gz', help='\nPath to vzstorage client log.\n\nThis option defines the log of cluster operations,\nit should include "%(cluster_name)s" template to separate\nlogs from multiple shares.\n\nRelated options:\n\n* vzstorage_mount_opts may include more detailed logging options.\n'), cfg.StrOpt('vzstorage_cache_path', default=None, help='\nPath to the SSD cache file.\n\nYou can attach an SSD drive to a client and configure the drive to store\na local cache of frequently accessed data. By having a local cache on a\nclient\'s SSD drive, you can increase the overall cluster performance by\nup to 10 and more times.\nWARNING! There is a lot of SSD models which are not server grade and\nmay loose arbitrary set of data changes on power loss.\nSuch SSDs should not be used in Vstorage and are dangerous as may lead\nto data corruptions and inconsistencies. Please consult with the manual\non which SSD models are known to be safe or verify it using\nvstorage-hwflush-check(1) utility.\n\nThis option defines the path which should include "%(cluster_name)s"\ntemplate to separate caches from multiple shares.\n\nRelated options:\n\n* vzstorage_mount_opts may include more detailed cache options.\n'), cfg.ListOpt('vzstorage_mount_opts', default=[], help='\nExtra mount options for pstorage-mount\n\nFor full description of them, see\nhttps://static.openvz.org/vz-man/man1/pstorage-mount.1.gz.html\nFormat is a python string representation of arguments list, like:\n"[\'-v\', \'-R\', \'500\']"\nShouldn\'t include -c, -l, -C, -u, -g and -m as those have\nexplicit vzstorage_* options.\n\nRelated options:\n\n* All other vzstorage_* options\n')]
QueueSizeType = types.Integer(choices=(256, 512, 1024))
libvirt_virtio_queue_sizes = [cfg.Opt('rx_queue_size', type=QueueSizeType, help='\nConfigure virtio rx queue size.\n\nThis option is only usable for virtio-net device with vhost and\nvhost-user backend. Available only with QEMU/KVM. Requires libvirt\nv2.3 QEMU v2.7.'), cfg.Opt('tx_queue_size', type=QueueSizeType, help='\nConfigure virtio tx queue size.\n\nThis option is only usable for virtio-net device with vhost-user\nbackend. Available only with QEMU/KVM. Requires libvirt v3.7 QEMU\nv2.10.'), cfg.IntOpt('max_queues', default=None, min=1, help='\nThe maximum number of virtio queue pairs that can be enabled\nwhen creating a multiqueue guest. The number of virtio queues\nallocated will be the lesser of the CPUs requested by the guest\nand the max value defined. By default, this value is set to none\nmeaning the legacy limits based on the reported kernel\nmajor version will be used.\n')]
libvirt_volume_nvmeof_opts = [cfg.IntOpt('num_nvme_discover_tries', default=5, help='\nNumber of times to rediscover NVMe target to find volume\n\nNova provides support for block storage attaching to hosts via NVMe\n(Non-Volatile Memory Express). This option allows the user to specify the\nmaximum number of retry attempts that can be made to discover the NVMe device.\n')]
libvirt_pmem_opts = [cfg.ListOpt('pmem_namespaces', item_type=cfg.types.String(), default=[], help='\nConfigure persistent memory(pmem) namespaces.\n\nThese namespaces must have been already created on the host. This config\noption is in the following format::\n\n    "$LABEL:$NSNAME[|$NSNAME][,$LABEL:$NSNAME[|$NSNAME]]"\n\n* ``$NSNAME`` is the name of the pmem namespace.\n* ``$LABEL`` represents one resource class, this is used to generate\n      the resource class name as ``CUSTOM_PMEM_NAMESPACE_$LABEL``.\n\nFor example::\n\n    [libvirt]\n    pmem_namespaces=128G:ns0|ns1|ns2|ns3,262144MB:ns4|ns5,MEDIUM:ns6|ns7\n\n')]
libvirt_vtpm_opts = [cfg.BoolOpt('swtpm_enabled', default=False, help='\nEnable emulated TPM (Trusted Platform Module) in guests.\n'), cfg.StrOpt('swtpm_user', default='tss', help='\nUser that swtpm binary runs as.\n\nWhen using emulated TPM, the ``swtpm`` binary will run to emulate a TPM\ndevice. The user this binary runs as depends on libvirt configuration, with\n``tss`` being the default.\n\nIn order to support cold migration and resize, nova needs to know what user\nthe swtpm binary is running as in order to ensure that files get the proper\nownership after being moved between nodes.\n\nRelated options:\n\n* ``swtpm_group`` must also be set.\n'), cfg.StrOpt('swtpm_group', default='tss', help='\nGroup that swtpm binary runs as.\n\nWhen using emulated TPM, the ``swtpm`` binary will run to emulate a TPM\ndevice. The user this binary runs as depends on libvirt configuration, with\n``tss`` being the default.\n\nIn order to support cold migration and resize, nova needs to know what group\nthe swtpm binary is running as in order to ensure that files get the proper\nownership after being moved between nodes.\n\nRelated options:\n\n* ``swtpm_user`` must also be set.\n')]
ALL_OPTS = list(itertools.chain(libvirt_general_opts, libvirt_imagebackend_opts, libvirt_lvm_opts, libvirt_utils_opts, libvirt_vif_opts, libvirt_volume_opts, libvirt_volume_aoe_opts, libvirt_volume_iscsi_opts, libvirt_volume_iser_opts, libvirt_volume_net_opts, libvirt_volume_nfs_opts, libvirt_volume_quobyte_opts, libvirt_volume_smbfs_opts, libvirt_remotefs_opts, libvirt_volume_vzstorage_opts, libvirt_virtio_queue_sizes, libvirt_volume_nvmeof_opts, libvirt_pmem_opts, libvirt_vtpm_opts))

@p.trace('register_opts')
def register_opts(conf):
    conf.register_group(libvirt_group)
    conf.register_opts(ALL_OPTS, group=libvirt_group)

@p.trace('list_opts')
def list_opts():
    return {libvirt_group: ALL_OPTS}