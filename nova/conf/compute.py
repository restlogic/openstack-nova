from bees import profiler as p
import socket
from oslo_config import cfg
from oslo_config import types
from nova.conf import paths
compute_group = cfg.OptGroup('compute', title='Compute Manager Options', help='\nA collection of options specific to the nova-compute service.\n')
compute_opts = [cfg.StrOpt('compute_driver', help='\nDefines which driver to use for controlling virtualization.\n\nPossible values:\n\n* ``libvirt.LibvirtDriver``\n* ``fake.FakeDriver``\n* ``ironic.IronicDriver``\n* ``vmwareapi.VMwareVCDriver``\n* ``hyperv.HyperVDriver``\n* ``powervm.PowerVMDriver``\n* ``zvm.ZVMDriver``\n'), cfg.BoolOpt('allow_resize_to_same_host', default=False, help='\nAllow destination machine to match source for resize. Useful when\ntesting in single-host environments. By default it is not allowed\nto resize to the same host. Setting this option to true will add\nthe same host to the destination options. Also set to true\nif you allow the ServerGroupAffinityFilter and need to resize.\n'), cfg.ListOpt('non_inheritable_image_properties', default=['cache_in_nova', 'bittorrent'], help="\nImage properties that should not be inherited from the instance\nwhen taking a snapshot.\n\nThis option gives an opportunity to select which image-properties\nshould not be inherited by newly created snapshots.\n\n.. note::\n\n   The following image properties are *never* inherited regardless of\n   whether they are listed in this configuration option or not:\n\n   * cinder_encryption_key_id\n   * cinder_encryption_key_deletion_policy\n   * img_signature\n   * img_signature_hash_method\n   * img_signature_key_type\n   * img_signature_certificate_uuid\n\nPossible values:\n\n* A comma-separated list whose item is an image property. Usually only\n  the image properties that are only needed by base images can be included\n  here, since the snapshots that are created from the base images don't\n  need them.\n* Default list: cache_in_nova, bittorrent\n\n"), cfg.IntOpt('max_local_block_devices', default=3, help='\nMaximum number of devices that will result in a local image being\ncreated on the hypervisor node.\n\nA negative number means unlimited. Setting ``max_local_block_devices``\nto 0 means that any request that attempts to create a local disk\nwill fail. This option is meant to limit the number of local discs\n(so root local disc that is the result of ``imageRef`` being used when\ncreating a server, and any other ephemeral and swap disks). 0 does not\nmean that images will be automatically converted to volumes and boot\ninstances from volumes - it just means that all requests that attempt\nto create a local disk will fail.\n\nPossible values:\n\n* 0: Creating a local disk is not allowed.\n* Negative number: Allows unlimited number of local discs.\n* Positive number: Allows only these many number of local discs.\n'), cfg.ListOpt('compute_monitors', default=[], help='\nA comma-separated list of monitors that can be used for getting\ncompute metrics. You can use the alias/name from the setuptools\nentry points for nova.compute.monitors.* namespaces. If no\nnamespace is supplied, the "cpu." namespace is assumed for\nbackwards-compatibility.\n\nNOTE: Only one monitor per namespace (For example: cpu) can be loaded at\na time.\n\nPossible values:\n\n* An empty list will disable the feature (Default).\n* An example value that would enable the CPU\n  bandwidth monitor that uses the virt driver variant::\n\n    compute_monitors = cpu.virt_driver\n'), cfg.StrOpt('default_ephemeral_format', help='\nThe default format an ephemeral_volume will be formatted with on creation.\n\nPossible values:\n\n* ``ext2``\n* ``ext3``\n* ``ext4``\n* ``xfs``\n* ``ntfs`` (only for Windows guests)\n'), cfg.BoolOpt('vif_plugging_is_fatal', default=True, help='\nDetermine if instance should boot or fail on VIF plugging timeout.\n\nNova sends a port update to Neutron after an instance has been scheduled,\nproviding Neutron with the necessary information to finish setup of the port.\nOnce completed, Neutron notifies Nova that it has finished setting up the\nport, at which point Nova resumes the boot of the instance since network\nconnectivity is now supposed to be present. A timeout will occur if the reply\nis not received after a given interval.\n\nThis option determines what Nova does when the VIF plugging timeout event\nhappens. When enabled, the instance will error out. When disabled, the\ninstance will continue to boot on the assumption that the port is ready.\n\nPossible values:\n\n* True: Instances should fail after VIF plugging timeout\n* False: Instances should continue booting after VIF plugging timeout\n'), cfg.IntOpt('vif_plugging_timeout', default=300, min=0, help='\nTimeout for Neutron VIF plugging event message arrival.\n\nNumber of seconds to wait for Neutron vif plugging events to\narrive before continuing or failing (see \'vif_plugging_is_fatal\').\n\nIf you are hitting timeout failures at scale, consider running rootwrap\nin "daemon mode" in the neutron agent via the ``[agent]/root_helper_daemon``\nneutron configuration option.\n\nRelated options:\n\n* vif_plugging_is_fatal - If ``vif_plugging_timeout`` is set to zero and\n  ``vif_plugging_is_fatal`` is False, events should not be expected to\n  arrive at all.\n'), cfg.IntOpt('arq_binding_timeout', default=300, min=1, help='\nTimeout for Accelerator Request (ARQ) bind event message arrival.\n\nNumber of seconds to wait for ARQ bind resolution event to arrive.\nThe event indicates that every ARQ for an instance has either bound\nsuccessfully or failed to bind. If it does not arrive, instance bringup\nis aborted with an exception.\n'), cfg.StrOpt('injected_network_template', default=paths.basedir_def('nova/virt/interfaces.template'), help="Path to '/etc/network/interfaces' template.\n\nThe path to a template file for the '/etc/network/interfaces'-style file, which\nwill be populated by nova and subsequently used by cloudinit. This provides a\nmethod to configure network connectivity in environments without a DHCP server.\n\nThe template will be rendered using Jinja2 template engine, and receive a\ntop-level key called ``interfaces``. This key will contain a list of\ndictionaries, one for each interface.\n\nRefer to the cloudinit documentaion for more information:\n\n  https://cloudinit.readthedocs.io/en/latest/topics/datasources.html\n\nPossible values:\n\n* A path to a Jinja2-formatted template for a Debian '/etc/network/interfaces'\n  file. This applies even if using a non Debian-derived guest.\n\nRelated options:\n\n* ``flat_inject``: This must be set to ``True`` to ensure nova embeds network\n  configuration information in the metadata provided through the config drive.\n"), cfg.StrOpt('preallocate_images', default='none', choices=[('none', 'No storage provisioning is done up front'), ('space', 'Storage is fully allocated at instance start')], help="\nThe image preallocation mode to use.\n\nImage preallocation allows storage for instance images to be allocated up front\nwhen the instance is initially provisioned. This ensures immediate feedback is\ngiven if enough space isn't available. In addition, it should significantly\nimprove performance on writes to new blocks and may even improve I/O\nperformance to prewritten blocks due to reduced fragmentation.\n"), cfg.BoolOpt('use_cow_images', default=True, help='\nEnable use of copy-on-write (cow) images.\n\nQEMU/KVM allow the use of qcow2 as backing files. By disabling this,\nbacking files will not be used.\n'), cfg.BoolOpt('force_raw_images', default=True, help='\nForce conversion of backing images to raw format.\n\nPossible values:\n\n* True: Backing image files will be converted to raw image format\n* False: Backing image files will not be converted\n\nRelated options:\n\n* ``compute_driver``: Only the libvirt driver uses this option.\n* ``[libvirt]/images_type``: If images_type is rbd, setting this option\n  to False is not allowed. See the bug\n  https://bugs.launchpad.net/nova/+bug/1816686 for more details.\n'), cfg.MultiStrOpt('virt_mkfs', default=[], help='\nName of the mkfs commands for ephemeral device.\n\nThe format is <os_type>=<mkfs command>\n'), cfg.BoolOpt('resize_fs_using_block_device', default=False, help='\nEnable resizing of filesystems via a block device.\n\nIf enabled, attempt to resize the filesystem by accessing the image over a\nblock device. This is done by the host and may not be necessary if the image\ncontains a recent version of cloud-init. Possible mechanisms require the nbd\ndriver (for qcow and raw), or loop (for raw).\n'), cfg.IntOpt('timeout_nbd', default=10, min=0, help='Amount of time, in seconds, to wait for NBD device start up.'), cfg.StrOpt('pointer_model', default='usbtablet', choices=[('ps2mouse', 'Uses relative movement. Mouse connected by PS2'), ('usbtablet', 'Uses absolute movement. Tablet connect by USB'), (None, 'Uses default behavior provided by drivers (mouse on PS2 for libvirt x86)')], help='\nGeneric property to specify the pointer type.\n\nInput devices allow interaction with a graphical framebuffer. For\nexample to provide a graphic tablet for absolute cursor movement.\n\nIf set, either the ``hw_input_bus`` or ``hw_pointer_model`` image metadata\nproperties will take precedence over this configuration option.\n\nRelated options:\n\n* usbtablet must be configured with VNC enabled or SPICE enabled and SPICE\n  agent disabled. When used with libvirt the instance mode should be\n  configured as HVM.\n ')]
resource_tracker_opts = [cfg.StrOpt('vcpu_pin_set', deprecated_for_removal=True, deprecated_since='20.0.0', deprecated_reason='\nThis option has been superseded by the ``[compute] cpu_dedicated_set`` and\n``[compute] cpu_shared_set`` options, which allow things like the co-existence\nof pinned and unpinned instances on the same host (for the libvirt driver).\n', help='\nMask of host CPUs that can be used for ``VCPU`` resources.\n\nThe behavior of this option depends on the definition of the ``[compute]\ncpu_dedicated_set`` option and affects the behavior of the ``[compute]\ncpu_shared_set`` option.\n\n* If ``[compute] cpu_dedicated_set`` is defined, defining this option will\n  result in an error.\n\n* If ``[compute] cpu_dedicated_set`` is not defined, this option will be used\n  to determine inventory for ``VCPU`` resources and to limit the host CPUs\n  that both pinned and unpinned instances can be scheduled to, overriding the\n  ``[compute] cpu_shared_set`` option.\n\nPossible values:\n\n* A comma-separated list of physical CPU numbers that virtual CPUs can be\n  allocated from. Each element should be either a single CPU number, a range of\n  CPU numbers, or a caret followed by a CPU number to be excluded from a\n  previous range. For example::\n\n    vcpu_pin_set = "4-12,^8,15"\n\nRelated options:\n\n* ``[compute] cpu_dedicated_set``\n* ``[compute] cpu_shared_set``\n'), cfg.MultiOpt('reserved_huge_pages', item_type=types.Dict(), help='\nNumber of huge/large memory pages to reserved per NUMA host cell.\n\nPossible values:\n\n* A list of valid key=value which reflect NUMA node ID, page size\n  (Default unit is KiB) and number of pages to be reserved. For example::\n\n    reserved_huge_pages = node:0,size:2048,count:64\n    reserved_huge_pages = node:1,size:1GB,count:1\n\n  In this example we are reserving on NUMA node 0 64 pages of 2MiB\n  and on NUMA node 1 1 page of 1GiB.\n'), cfg.IntOpt('reserved_host_disk_mb', min=0, default=0, help='\nAmount of disk resources in MB to make them always available to host. The\ndisk usage gets reported back to the scheduler from nova-compute running\non the compute nodes. To prevent the disk resources from being considered\nas available, this option can be used to reserve disk space for that host.\n\nPossible values:\n\n* Any positive integer representing amount of disk in MB to reserve\n  for the host.\n'), cfg.IntOpt('reserved_host_memory_mb', default=512, min=0, help='\nAmount of memory in MB to reserve for the host so that it is always available\nto host processes. The host resources usage is reported back to the scheduler\ncontinuously from nova-compute running on the compute node. To prevent the host\nmemory from being considered as available, this option is used to reserve\nmemory for the host.\n\nPossible values:\n\n* Any positive integer representing amount of memory in MB to reserve\n  for the host.\n'), cfg.IntOpt('reserved_host_cpus', default=0, min=0, help='\nNumber of host CPUs to reserve for host processes.\n\nThe host resources usage is reported back to the scheduler continuously from\nnova-compute running on the compute node. This value is used to determine the\n``reserved`` value reported to placement.\n\nThis option cannot be set if the ``[compute] cpu_shared_set`` or ``[compute]\ncpu_dedicated_set`` config options have been defined. When these options are\ndefined, any host CPUs not included in these values are considered reserved for\nthe host.\n\nPossible values:\n\n* Any positive integer representing number of physical CPUs to reserve\n  for the host.\n\nRelated options:\n\n* ``[compute] cpu_shared_set``\n* ``[compute] cpu_dedicated_set``\n')]
allocation_ratio_opts = [cfg.FloatOpt('cpu_allocation_ratio', default=None, min=0.0, help='\nVirtual CPU to physical CPU allocation ratio.\n\nThis option is used to influence the hosts selected by the Placement API by\nconfiguring the allocation ratio for ``VCPU`` inventory. In addition, the\n``AggregateCoreFilter`` (deprecated) will fall back to this configuration value\nif no per-aggregate setting is found.\n\n.. note::\n\n   This option does not affect ``PCPU`` inventory, which cannot be\n   overcommitted.\n\n.. note::\n\n   If this option is set to something *other than* ``None`` or ``0.0``, the\n   allocation ratio will be overwritten by the value of this option, otherwise,\n   the allocation ratio will not change. Once set to a non-default value, it is\n   not possible to "unset" the config to get back to the default behavior. If\n   you want to reset back to the initial value, explicitly specify it to the\n   value of ``initial_cpu_allocation_ratio``.\n\nPossible values:\n\n* Any valid positive integer or float value\n\nRelated options:\n\n* ``initial_cpu_allocation_ratio``\n'), cfg.FloatOpt('ram_allocation_ratio', default=None, min=0.0, help='\nVirtual RAM to physical RAM allocation ratio.\n\nThis option is used to influence the hosts selected by the Placement API by\nconfiguring the allocation ratio for ``MEMORY_MB`` inventory. In addition, the\n``AggregateRamFilter`` (deprecated) will fall back to this configuration value\nif no per-aggregate setting is found.\n\n.. note::\n\n   If this option is set to something *other than* ``None`` or ``0.0``, the\n   allocation ratio will be overwritten by the value of this option, otherwise,\n   the allocation ratio will not change. Once set to a non-default value, it is\n   not possible to "unset" the config to get back to the default behavior. If\n   you want to reset back to the initial value, explicitly specify it to the\n   value of ``initial_ram_allocation_ratio``.\n\nPossible values:\n\n* Any valid positive integer or float value\n\nRelated options:\n\n* ``initial_ram_allocation_ratio``\n'), cfg.FloatOpt('disk_allocation_ratio', default=None, min=0.0, help='\nVirtual disk to physical disk allocation ratio.\n\nThis option is used to influence the hosts selected by the Placement API by\nconfiguring the allocation ratio for ``DISK_GB`` inventory. In addition, the\n``AggregateDiskFilter`` (deprecated) will fall back to this configuration value\nif no per-aggregate setting is found.\n\nWhen configured, a ratio greater than 1.0 will result in over-subscription of\nthe available physical disk, which can be useful for more efficiently packing\ninstances created with images that do not use the entire virtual disk, such as\nsparse or compressed images. It can be set to a value between 0.0 and 1.0 in\norder to preserve a percentage of the disk for uses other than instances.\n\n.. note::\n\n   If the value is set to ``>1``, we recommend keeping track of the free disk\n   space, as the value approaching ``0`` may result in the incorrect\n   functioning of instances using it at the moment.\n\n.. note::\n\n   If this option is set to something *other than* ``None`` or ``0.0``, the\n   allocation ratio will be overwritten by the value of this option, otherwise,\n   the allocation ratio will not change. Once set to a non-default value, it is\n   not possible to "unset" the config to get back to the default behavior. If\n   you want to reset back to the initial value, explicitly specify it to the\n   value of ``initial_disk_allocation_ratio``.\n\nPossible values:\n\n* Any valid positive integer or float value\n\nRelated options:\n\n* ``initial_disk_allocation_ratio``\n'), cfg.FloatOpt('initial_cpu_allocation_ratio', default=16.0, min=0.0, help='\nInitial virtual CPU to physical CPU allocation ratio.\n\nThis is only used when initially creating the ``computes_nodes`` table record\nfor a given nova-compute service.\n\nSee https://docs.openstack.org/nova/latest/admin/configuration/schedulers.html\nfor more details and usage scenarios.\n\nRelated options:\n\n* ``cpu_allocation_ratio``\n'), cfg.FloatOpt('initial_ram_allocation_ratio', default=1.5, min=0.0, help='\nInitial virtual RAM to physical RAM allocation ratio.\n\nThis is only used when initially creating the ``computes_nodes`` table record\nfor a given nova-compute service.\n\nSee https://docs.openstack.org/nova/latest/admin/configuration/schedulers.html\nfor more details and usage scenarios.\n\nRelated options:\n\n* ``ram_allocation_ratio``\n'), cfg.FloatOpt('initial_disk_allocation_ratio', default=1.0, min=0.0, help='\nInitial virtual disk to physical disk allocation ratio.\n\nThis is only used when initially creating the ``computes_nodes`` table record\nfor a given nova-compute service.\n\nSee https://docs.openstack.org/nova/latest/admin/configuration/schedulers.html\nfor more details and usage scenarios.\n\nRelated options:\n\n* ``disk_allocation_ratio``\n')]
compute_manager_opts = [cfg.StrOpt('console_host', default=socket.gethostname(), sample_default='<current_hostname>', help='\nConsole proxy host to be used to connect to instances on this host. It is the\npublicly visible name for the console host.\n\nPossible values:\n\n* Current hostname (default) or any string representing hostname.\n'), cfg.StrOpt('default_access_ip_network_name', help='\nName of the network to be used to set access IPs for instances. If there are\nmultiple IPs to choose from, an arbitrary one will be chosen.\n\nPossible values:\n\n* None (default)\n* Any string representing network name.\n'), cfg.StrOpt('instances_path', default=paths.state_path_def('instances'), sample_default='$state_path/instances', help="\nSpecifies where instances are stored on the hypervisor's disk.\nIt can point to locally attached storage or a directory on NFS.\n\nPossible values:\n\n* $state_path/instances where state_path is a config option that specifies\n  the top-level directory for maintaining nova's state. (default) or\n  Any string representing directory path.\n\nRelated options:\n\n* ``[workarounds]/ensure_libvirt_rbd_instance_dir_cleanup``\n"), cfg.BoolOpt('instance_usage_audit', default=False, help='\nThis option enables periodic compute.instance.exists notifications. Each\ncompute node must be configured to generate system usage data. These\nnotifications are consumed by OpenStack Telemetry service.\n'), cfg.IntOpt('live_migration_retry_count', default=30, min=0, help='\nMaximum number of 1 second retries in live_migration. It specifies number\nof retries to iptables when it complains. It happens when an user continuously\nsends live-migration request to same host leading to concurrent request\nto iptables.\n\nPossible values:\n\n* Any positive integer representing retry count.\n'), cfg.BoolOpt('resume_guests_state_on_host_boot', default=False, help='\nThis option specifies whether to start guests that were running before the\nhost rebooted. It ensures that all of the instances on a Nova compute node\nresume their state each time the compute node boots or restarts.\n'), cfg.IntOpt('network_allocate_retries', default=0, min=0, help='\nNumber of times to retry network allocation. It is required to attempt network\nallocation retries if the virtual interface plug fails.\n\nPossible values:\n\n* Any positive integer representing retry count.\n'), cfg.IntOpt('max_concurrent_builds', default=10, min=0, help='\nLimits the maximum number of instance builds to run concurrently by\nnova-compute. Compute service can attempt to build an infinite number of\ninstances, if asked to do so. This limit is enforced to avoid building\nunlimited instance concurrently on a compute node. This value can be set\nper compute node.\n\nPossible Values:\n\n* 0 : treated as unlimited.\n* Any positive integer representing maximum concurrent builds.\n'), cfg.IntOpt('max_concurrent_snapshots', default=5, min=0, help='\nMaximum number of instance snapshot operations to run concurrently.\nThis limit is enforced to prevent snapshots overwhelming the\nhost/network/storage and causing failure. This value can be set per\ncompute node.\n\nPossible Values:\n\n* 0 : treated as unlimited.\n* Any positive integer representing maximum concurrent snapshots.\n'), cfg.IntOpt('max_concurrent_live_migrations', default=1, min=0, help='\nMaximum number of live migrations to run concurrently. This limit is enforced\nto avoid outbound live migrations overwhelming the host/network and causing\nfailures. It is not recommended that you change this unless you are very sure\nthat doing so is safe and stable in your environment.\n\nPossible values:\n\n* 0 : treated as unlimited.\n* Any positive integer representing maximum number of live migrations\n  to run concurrently.\n'), cfg.IntOpt('block_device_allocate_retries', default=60, min=0, help='\nThe number of times to check for a volume to be "available" before attaching\nit during server create.\n\nWhen creating a server with block device mappings where ``source_type`` is\none of ``blank``, ``image`` or ``snapshot`` and the ``destination_type`` is\n``volume``, the ``nova-compute`` service will create a volume and then attach\nit to the server. Before the volume can be attached, it must be in status\n"available". This option controls how many times to check for the created\nvolume to be "available" before it is attached.\n\nIf the operation times out, the volume will be deleted if the block device\nmapping ``delete_on_termination`` value is True.\n\nIt is recommended to configure the image cache in the block storage service\nto speed up this operation. See\nhttps://docs.openstack.org/cinder/latest/admin/blockstorage-image-volume-cache.html\nfor details.\n\nPossible values:\n\n* 60 (default)\n* If value is 0, then one attempt is made.\n* For any value > 0, total attempts are (value + 1)\n\nRelated options:\n\n* ``block_device_allocate_retries_interval`` - controls the interval between\n  checks\n'), cfg.IntOpt('sync_power_state_pool_size', default=1000, help='\nNumber of greenthreads available for use to sync power states.\n\nThis option can be used to reduce the number of concurrent requests\nmade to the hypervisor or system with real instance power states\nfor performance reasons, for example, with Ironic.\n\nPossible values:\n\n* Any positive integer representing greenthreads count.\n')]
compute_group_opts = [cfg.IntOpt('consecutive_build_service_disable_threshold', default=10, help='\nEnables reporting of build failures to the scheduler.\n\nAny nonzero value will enable sending build failure statistics to the\nscheduler for use by the BuildFailureWeigher.\n\nPossible values:\n\n* Any positive integer enables reporting build failures.\n* Zero to disable reporting build failures.\n\nRelated options:\n\n* [filter_scheduler]/build_failure_weight_multiplier\n\n'), cfg.IntOpt('shutdown_retry_interval', default=10, min=1, help='\nTime to wait in seconds before resending an ACPI shutdown signal to\ninstances.\n\nThe overall time to wait is set by ``shutdown_timeout``.\n\nPossible values:\n\n* Any integer greater than 0 in seconds\n\nRelated options:\n\n* ``shutdown_timeout``\n'), cfg.IntOpt('resource_provider_association_refresh', default=300, min=0, mutable=True, help="\nInterval for updating nova-compute-side cache of the compute node resource\nprovider's inventories, aggregates, and traits.\n\nThis option specifies the number of seconds between attempts to update a\nprovider's inventories, aggregates and traits in the local cache of the compute\nnode.\n\nA value of zero disables cache refresh completely.\n\nThe cache can be cleared manually at any time by sending SIGHUP to the compute\nprocess, causing it to be repopulated the next time the data is accessed.\n\nPossible values:\n\n* Any positive integer in seconds, or zero to disable refresh.\n"), cfg.StrOpt('cpu_shared_set', help='\nMask of host CPUs that can be used for ``VCPU`` resources and offloaded\nemulator threads.\n\nThe behavior of this option depends on the definition of the deprecated\n``vcpu_pin_set`` option.\n\n* If ``vcpu_pin_set`` is not defined, ``[compute] cpu_shared_set`` will be be\n  used to provide ``VCPU`` inventory and to determine the host CPUs that\n  unpinned instances can be scheduled to. It will also be used to determine the\n  host CPUS that instance emulator threads should be offloaded to for instances\n  configured with the ``share`` emulator thread policy\n  (``hw:emulator_threads_policy=share``).\n\n* If ``vcpu_pin_set`` is defined, ``[compute] cpu_shared_set`` will only be\n  used to determine the host CPUs that instance emulator threads should be\n  offloaded to for instances configured with the ``share`` emulator thread\n  policy (``hw:emulator_threads_policy=share``). ``vcpu_pin_set`` will be used\n  to provide ``VCPU`` inventory and to determine the host CPUs that both pinned\n  and unpinned instances can be scheduled to.\n\nThis behavior will be simplified in a future release when ``vcpu_pin_set`` is\nremoved.\n\nPossible values:\n\n* A comma-separated list of physical CPU numbers that instance VCPUs can be\n  allocated from. Each element should be either a single CPU number, a range of\n  CPU numbers, or a caret followed by a CPU number to be excluded from a\n  previous range. For example::\n\n    cpu_shared_set = "4-12,^8,15"\n\nRelated options:\n\n* ``[compute] cpu_dedicated_set``: This is the counterpart option for defining\n  where ``PCPU`` resources should be allocated from.\n* ``vcpu_pin_set``: A legacy option whose definition may change the behavior of\n  this option.\n'), cfg.StrOpt('cpu_dedicated_set', help='\nMask of host CPUs that can be used for ``PCPU`` resources.\n\nThe behavior of this option affects the behavior of the deprecated\n``vcpu_pin_set`` option.\n\n* If this option is defined, defining ``vcpu_pin_set`` will result in an error.\n\n* If this option is not defined, ``vcpu_pin_set`` will be used to determine\n  inventory for ``VCPU`` resources and to limit the host CPUs that both pinned\n  and unpinned instances can be scheduled to.\n\nThis behavior will be simplified in a future release when ``vcpu_pin_set`` is\nremoved.\n\nPossible values:\n\n* A comma-separated list of physical CPU numbers that instance VCPUs can be\n  allocated from. Each element should be either a single CPU number, a range of\n  CPU numbers, or a caret followed by a CPU number to be excluded from a\n  previous range. For example::\n\n    cpu_dedicated_set = "4-12,^8,15"\n\nRelated options:\n\n* ``[compute] cpu_shared_set``: This is the counterpart option for defining\n  where ``VCPU`` resources should be allocated from.\n* ``vcpu_pin_set``: A legacy option that this option partially replaces.\n'), cfg.BoolOpt('live_migration_wait_for_vif_plug', default=True, help='\nDetermine if the source compute host should wait for a ``network-vif-plugged``\nevent from the (neutron) networking service before starting the actual transfer\nof the guest to the destination compute host.\n\nNote that this option is read on the destination host of a live migration.\nIf you set this option the same on all of your compute hosts, which you should\ndo if you use the same networking backend universally, you do not have to\nworry about this.\n\nBefore starting the transfer of the guest, some setup occurs on the destination\ncompute host, including plugging virtual interfaces. Depending on the\nnetworking backend **on the destination host**, a ``network-vif-plugged``\nevent may be triggered and then received on the source compute host and the\nsource compute can wait for that event to ensure networking is set up on the\ndestination host before starting the guest transfer in the hypervisor.\n\n.. note::\n\n   The compute service cannot reliably determine which types of virtual\n   interfaces (``port.binding:vif_type``) will send ``network-vif-plugged``\n   events without an accompanying port ``binding:host_id`` change.\n   Open vSwitch and linuxbridge should be OK, but OpenDaylight is at least\n   one known backend that will not currently work in this case, see bug\n   https://launchpad.net/bugs/1755890 for more details.\n\nPossible values:\n\n* True: wait for ``network-vif-plugged`` events before starting guest transfer\n* False: do not wait for ``network-vif-plugged`` events before starting guest\n  transfer (this is the legacy behavior)\n\nRelated options:\n\n* [DEFAULT]/vif_plugging_is_fatal: if ``live_migration_wait_for_vif_plug`` is\n  True and ``vif_plugging_timeout`` is greater than 0, and a timeout is\n  reached, the live migration process will fail with an error but the guest\n  transfer will not have started to the destination host\n* [DEFAULT]/vif_plugging_timeout: if ``live_migration_wait_for_vif_plug`` is\n  True, this controls the amount of time to wait before timing out and either\n  failing if ``vif_plugging_is_fatal`` is True, or simply continuing with the\n  live migration\n'), cfg.IntOpt('max_concurrent_disk_ops', default=0, min=0, help='\nNumber of concurrent disk-IO-intensive operations (glance image downloads,\nimage format conversions, etc.) that we will do in parallel.  If this is set\ntoo high then response time suffers.\nThe default value of 0 means no limit.\n '), cfg.IntOpt('max_disk_devices_to_attach', default=-1, min=-1, help='\nMaximum number of disk devices allowed to attach to a single server. Note\nthat the number of disks supported by an server depends on the bus used. For\nexample, the ``ide`` disk bus is limited to 4 attached devices. The configured\nmaximum is enforced during server create, rebuild, evacuate, unshelve, live\nmigrate, and attach volume.\n\nUsually, disk bus is determined automatically from the device type or disk\ndevice, and the virtualization type. However, disk bus\ncan also be specified via a block device mapping or an image property.\nSee the ``disk_bus`` field in :doc:`/user/block-device-mapping` for more\ninformation about specifying disk bus in a block device mapping, and\nsee https://docs.openstack.org/glance/latest/admin/useful-image-properties.html\nfor more information about the ``hw_disk_bus`` image property.\n\nOperators changing the ``[compute]/max_disk_devices_to_attach`` on a compute\nservice that is hosting servers should be aware that it could cause rebuilds to\nfail, if the maximum is decreased lower than the number of devices already\nattached to servers. For example, if server A has 26 devices attached and an\noperators changes ``[compute]/max_disk_devices_to_attach`` to 20, a request to\nrebuild server A will fail and go into ERROR state because 26 devices are\nalready attached and exceed the new configured maximum of 20.\n\nOperators setting ``[compute]/max_disk_devices_to_attach`` should also be aware\nthat during a cold migration, the configured maximum is only enforced in-place\nand the destination is not checked before the move. This means if an operator\nhas set a maximum of 26 on compute host A and a maximum of 20 on compute host\nB, a cold migration of a server with 26 attached devices from compute host A to\ncompute host B will succeed. Then, once the server is on compute host B, a\nsubsequent request to rebuild the server will fail and go into ERROR state\nbecause 26 devices are already attached and exceed the configured maximum of 20\non compute host B.\n\nThe configured maximum is not enforced on shelved offloaded servers, as they\nhave no compute host.\n\n.. warning:: If this option is set to 0, the ``nova-compute`` service will fail\n             to start, as 0 disk devices is an invalid configuration that would\n             prevent instances from being able to boot.\n\nPossible values:\n\n* -1 means unlimited\n* Any integer >= 1 represents the maximum allowed. A value of 0 will cause the\n  ``nova-compute`` service to fail to start, as 0 disk devices is an invalid\n  configuration that would prevent instances from being able to boot.\n'), cfg.StrOpt('provider_config_location', default='/etc/nova/provider_config/', help='\nLocation of YAML files containing resource provider configuration data.\n\nThese files allow the operator to specify additional custom inventory and\ntraits to assign to one or more resource providers.\n\nAdditional documentation is available here:\n\n  https://docs.openstack.org/nova/latest/admin/managing-resource-providers.html\n\n'), cfg.ListOpt('image_type_exclude_list', default=[], help='\nA list of image formats that should not be advertised as supported by this\ncompute node.\n\nIn some situations, it may be desirable to have a compute node\nrefuse to support an expensive or complex image format. This factors into\nthe decisions made by the scheduler about which compute node to select when\nbooted with a given image.\n\nPossible values:\n\n* Any glance image ``disk_format`` name (i.e. ``raw``, ``qcow2``, etc)\n\nRelated options:\n\n* ``[scheduler]query_placement_for_image_type_support`` - enables\n  filtering computes based on supported image types, which is required\n  to be enabled for this to take effect.\n')]
interval_opts = [cfg.IntOpt('sync_power_state_interval', default=600, help='\nInterval to sync power states between the database and the hypervisor.\n\nThe interval that Nova checks the actual virtual machine power state\nand the power state that Nova has in its database. If a user powers\ndown their VM, Nova updates the API to report the VM has been\npowered down. Should something turn on the VM unexpectedly,\nNova will turn the VM back off to keep the system in the expected\nstate.\n\nPossible values:\n\n* 0: Will run at the default periodic interval.\n* Any value < 0: Disables the option.\n* Any positive integer in seconds.\n\nRelated options:\n\n* If ``handle_virt_lifecycle_events`` in the ``workarounds`` group is\n  false and this option is negative, then instances that get out\n  of sync between the hypervisor and the Nova database will have\n  to be synchronized manually.\n'), cfg.IntOpt('heal_instance_info_cache_interval', default=60, help="\nInterval between instance network information cache updates.\n\nNumber of seconds after which each compute node runs the task of\nquerying Neutron for all of its instances networking information,\nthen updates the Nova db with that information. Nova will never\nupdate it's cache if this option is set to 0. If we don't update the\ncache, the metadata service and nova-api endpoints will be proxying\nincorrect network data about the instance. So, it is not recommended\nto set this option to 0.\n\nPossible values:\n\n* Any positive integer in seconds.\n* Any value <=0 will disable the sync. This is not recommended.\n"), cfg.IntOpt('reclaim_instance_interval', default=0, help="\nInterval for reclaiming deleted instances.\n\nA value greater than 0 will enable SOFT_DELETE of instances.\nThis option decides whether the server to be deleted will be put into\nthe SOFT_DELETED state. If this value is greater than 0, the deleted\nserver will not be deleted immediately, instead it will be put into\na queue until it's too old (deleted time greater than the value of\nreclaim_instance_interval). The server can be recovered from the\ndelete queue by using the restore action. If the deleted server remains\nlonger than the value of reclaim_instance_interval, it will be\ndeleted by a periodic task in the compute service automatically.\n\nNote that this option is read from both the API and compute nodes, and\nmust be set globally otherwise servers could be put into a soft deleted\nstate in the API and never actually reclaimed (deleted) on the compute\nnode.\n\n.. note:: When using this option, you should also configure the ``[cinder]``\n          auth options, e.g. ``auth_type``, ``auth_url``, ``username``, etc.\n          Since the reclaim happens in a periodic task, there is no user token\n          to cleanup volumes attached to any SOFT_DELETED servers so nova must\n          be configured with administrator role access to cleanup those\n          resources in cinder.\n\nPossible values:\n\n* Any positive integer(in seconds) greater than 0 will enable\n  this option.\n* Any value <=0 will disable the option.\n\nRelated options:\n\n* [cinder] auth options for cleaning up volumes attached to servers during\n  the reclaim process\n"), cfg.IntOpt('volume_usage_poll_interval', default=0, help='\nInterval for gathering volume usages.\n\nThis option updates the volume usage cache for every\nvolume_usage_poll_interval number of seconds.\n\nPossible values:\n\n* Any positive integer(in seconds) greater than 0 will enable\n  this option.\n* Any value <=0 will disable the option.\n'), cfg.IntOpt('shelved_poll_interval', default=3600, help="\nInterval for polling shelved instances to offload.\n\nThe periodic task runs for every shelved_poll_interval number\nof seconds and checks if there are any shelved instances. If it\nfinds a shelved instance, based on the 'shelved_offload_time' config\nvalue it offloads the shelved instances. Check 'shelved_offload_time'\nconfig option description for details.\n\nPossible values:\n\n* Any value <= 0: Disables the option.\n* Any positive integer in seconds.\n\nRelated options:\n\n* ``shelved_offload_time``\n"), cfg.IntOpt('shelved_offload_time', default=0, help='\nTime before a shelved instance is eligible for removal from a host.\n\nBy default this option is set to 0 and the shelved instance will be\nremoved from the hypervisor immediately after shelve operation.\nOtherwise, the instance will be kept for the value of\nshelved_offload_time(in seconds) so that during the time period the\nunshelve action will be faster, then the periodic task will remove\nthe instance from hypervisor after shelved_offload_time passes.\n\nPossible values:\n\n* 0: Instance will be immediately offloaded after being\n     shelved.\n* Any value < 0: An instance will never offload.\n* Any positive integer in seconds: The instance will exist for\n  the specified number of seconds before being offloaded.\n'), cfg.IntOpt('instance_delete_interval', default=300, help="\nInterval for retrying failed instance file deletes.\n\nThis option depends on 'maximum_instance_delete_attempts'.\nThis option specifies how often to retry deletes whereas\n'maximum_instance_delete_attempts' specifies the maximum number\nof retry attempts that can be made.\n\nPossible values:\n\n* 0: Will run at the default periodic interval.\n* Any value < 0: Disables the option.\n* Any positive integer in seconds.\n\nRelated options:\n\n* ``maximum_instance_delete_attempts`` from instance_cleaning_opts\n  group.\n"), cfg.IntOpt('block_device_allocate_retries_interval', default=3, min=0, help='\nInterval (in seconds) between block device allocation retries on failures.\n\nThis option allows the user to specify the time interval between\nconsecutive retries. The ``block_device_allocate_retries`` option specifies\nthe maximum number of retries.\n\nPossible values:\n\n* 0: Disables the option.\n* Any positive integer in seconds enables the option.\n\nRelated options:\n\n* ``block_device_allocate_retries`` - controls the number of retries\n'), cfg.IntOpt('scheduler_instance_sync_interval', default=120, help="\nInterval between sending the scheduler a list of current instance UUIDs to\nverify that its view of instances is in sync with nova.\n\nIf the CONF option 'scheduler_tracks_instance_changes' is\nFalse, the sync calls will not be made. So, changing this option will\nhave no effect.\n\nIf the out of sync situations are not very common, this interval\ncan be increased to lower the number of RPC messages being sent.\nLikewise, if sync issues turn out to be a problem, the interval\ncan be lowered to check more frequently.\n\nPossible values:\n\n* 0: Will run at the default periodic interval.\n* Any value < 0: Disables the option.\n* Any positive integer in seconds.\n\nRelated options:\n\n* This option has no impact if ``scheduler_tracks_instance_changes``\n  is set to False.\n"), cfg.IntOpt('update_resources_interval', default=0, help='\nInterval for updating compute resources.\n\nThis option specifies how often the update_available_resource\nperiodic task should run. A number less than 0 means to disable the\ntask completely. Leaving this at the default of 0 will cause this to\nrun at the default periodic interval. Setting it to any positive\nvalue will cause it to run at approximately that number of seconds.\n\nPossible values:\n\n* 0: Will run at the default periodic interval.\n* Any value < 0: Disables the option.\n* Any positive integer in seconds.\n')]
timeout_opts = [cfg.IntOpt('reboot_timeout', default=0, min=0, help='\nTime interval after which an instance is hard rebooted automatically.\n\nWhen doing a soft reboot, it is possible that a guest kernel is\ncompletely hung in a way that causes the soft reboot task\nto not ever finish. Setting this option to a time period in seconds\nwill automatically hard reboot an instance if it has been stuck\nin a rebooting state longer than N seconds.\n\nPossible values:\n\n* 0: Disables the option (default).\n* Any positive integer in seconds: Enables the option.\n'), cfg.IntOpt('instance_build_timeout', default=0, min=0, help='\nMaximum time in seconds that an instance can take to build.\n\nIf this timer expires, instance status will be changed to ERROR.\nEnabling this option will make sure an instance will not be stuck\nin BUILD state for a longer period.\n\nPossible values:\n\n* 0: Disables the option (default)\n* Any positive integer in seconds: Enables the option.\n'), cfg.IntOpt('rescue_timeout', default=0, min=0, help='\nInterval to wait before un-rescuing an instance stuck in RESCUE.\n\nPossible values:\n\n* 0: Disables the option (default)\n* Any positive integer in seconds: Enables the option.\n'), cfg.IntOpt('resize_confirm_window', default=0, min=0, help='\nAutomatically confirm resizes after N seconds.\n\nResize functionality will save the existing server before resizing.\nAfter the resize completes, user is requested to confirm the resize.\nThe user has the opportunity to either confirm or revert all\nchanges. Confirm resize removes the original server and changes\nserver status from resized to active. Setting this option to a time\nperiod (in seconds) will automatically confirm the resize if the\nserver is in resized state longer than that time.\n\nPossible values:\n\n* 0: Disables the option (default)\n* Any positive integer in seconds: Enables the option.\n'), cfg.IntOpt('shutdown_timeout', default=60, min=0, help='\nTotal time to wait in seconds for an instance to perform a clean\nshutdown.\n\nIt determines the overall period (in seconds) a VM is allowed to\nperform a clean shutdown. While performing stop, rescue and shelve,\nrebuild operations, configuring this option gives the VM a chance\nto perform a controlled shutdown before the instance is powered off.\nThe default timeout is 60 seconds. A value of 0 (zero) means the guest\nwill be powered off immediately with no opportunity for guest OS clean-up.\n\nThe timeout value can be overridden on a per image basis by means\nof os_shutdown_timeout that is an image metadata setting allowing\ndifferent types of operating systems to specify how much time they\nneed to shut down cleanly.\n\nPossible values:\n\n* A positive integer or 0 (default value is 60).\n')]
running_deleted_opts = [cfg.StrOpt('running_deleted_instance_action', default='reap', choices=[('reap', 'Powers down the instances and deletes them'), ('log', 'Logs warning message about deletion of the resource'), ('shutdown', 'Powers down instances and marks them as non-bootable which can be later used for debugging/analysis'), ('noop', 'Takes no action')], help='\nThe compute service periodically checks for instances that have been\ndeleted in the database but remain running on the compute node. The\nabove option enables action to be taken when such instances are\nidentified.\n\nRelated options:\n\n* ``running_deleted_instance_poll_interval``\n* ``running_deleted_instance_timeout``\n'), cfg.IntOpt('running_deleted_instance_poll_interval', default=1800, help='\nTime interval in seconds to wait between runs for the clean up action.\nIf set to 0, above check will be disabled. If "running_deleted_instance\n_action" is set to "log" or "reap", a value greater than 0 must be set.\n\nPossible values:\n\n* Any positive integer in seconds enables the option.\n* 0: Disables the option.\n* 1800: Default value.\n\nRelated options:\n\n* running_deleted_instance_action\n'), cfg.IntOpt('running_deleted_instance_timeout', default=0, help='\nTime interval in seconds to wait for the instances that have\nbeen marked as deleted in database to be eligible for cleanup.\n\nPossible values:\n\n* Any positive integer in seconds(default is 0).\n\nRelated options:\n\n* "running_deleted_instance_action"\n')]
instance_cleaning_opts = [cfg.IntOpt('maximum_instance_delete_attempts', default=5, min=1, help="\nThe number of times to attempt to reap an instance's files.\n\nThis option specifies the maximum number of retry attempts\nthat can be made.\n\nPossible values:\n\n* Any positive integer defines how many attempts are made.\n\nRelated options:\n\n* ``[DEFAULT] instance_delete_interval`` can be used to disable this option.\n")]
db_opts = [cfg.StrOpt('osapi_compute_unique_server_name_scope', default='', choices=[('', 'An empty value means that no uniqueness check is done and duplicate names are possible'), ('project', 'The instance name check is done only for instances within the same project'), ('global', 'The instance name check is done for all instances regardless of the project')], help="\nSets the scope of the check for unique instance names.\n\nThe default doesn't check for unique names. If a scope for the name check is\nset, a launch of a new instance or an update of an existing instance with a\nduplicate name will result in an ''InstanceExists'' error. The uniqueness is\ncase-insensitive. Setting this option can increase the usability for end\nusers as they don't have to distinguish among instances with the same name\nby their IDs.\n"), cfg.BoolOpt('enable_new_services', default=True, help='\nEnable new nova-compute services on this host automatically.\n\nWhen a new nova-compute service starts up, it gets\nregistered in the database as an enabled service. Sometimes it can be useful\nto register new compute services in disabled state and then enabled them at a\nlater point in time. This option only sets this behavior for nova-compute\nservices, it does not auto-disable other services like nova-conductor,\nnova-scheduler, or nova-osapi_compute.\n\nPossible values:\n\n* ``True``: Each new compute service is enabled as soon as it registers itself.\n* ``False``: Compute services must be enabled via an os-services REST API call\n  or with the CLI with ``nova service-enable <hostname> <binary>``, otherwise\n  they are not ready to use.\n'), cfg.StrOpt('instance_name_template', default='instance-%08x', help='\nTemplate string to be used to generate instance names.\n\nThis template controls the creation of the database name of an instance. This\nis *not* the display name you enter when creating an instance (via Horizon\nor CLI). For a new deployment it is advisable to change the default value\n(which uses the database autoincrement) to another value which makes use\nof the attributes of an instance, like ``instance-%(uuid)s``. If you\nalready have instances in your deployment when you change this, your\ndeployment will break.\n\nPossible values:\n\n* A string which either uses the instance database ID (like the\n  default)\n* A string with a list of named database columns, for example ``%(id)d``\n  or ``%(uuid)s`` or ``%(hostname)s``.\n')]
ALL_OPTS = compute_opts + resource_tracker_opts + allocation_ratio_opts + compute_manager_opts + interval_opts + timeout_opts + running_deleted_opts + instance_cleaning_opts + db_opts

@p.trace('register_opts')
def register_opts(conf):
    conf.register_opts(ALL_OPTS)
    conf.register_group(compute_group)
    conf.register_opts(compute_group_opts, group=compute_group)

@p.trace('list_opts')
def list_opts():
    return {'DEFAULT': ALL_OPTS, 'compute': compute_group_opts}